{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cete","text":""},{"location":"#features","title":"Features","text":"<ul> <li>Easy deployment</li> <li>Bringing up cluster</li> <li>Database replication</li> <li>An easy-to-use HTTP API</li> <li>CLI is also available</li> <li>Docker container image is available</li> </ul>"},{"location":"#building-cete","title":"Building Cete","text":"<p>When you satisfied dependencies, let's build Cete for Linux as following:</p> <pre><code>$ mkdir -p ${GOPATH}/src/github.com/mosuka\n$ cd ${GOPATH}/src/github.com/mosuka\n$ git clone https://github.com/mosuka/cete.git\n$ cd cete\n$ make build\n</code></pre> <p>If you want to build for other platform, set <code>GOOS</code>, <code>GOARCH</code> environment variables. For example, build for macOS like following:</p> <pre><code>$ make GOOS=darwin build\n</code></pre>"},{"location":"#binaries","title":"Binaries","text":"<p>You can see the binary file when build successful like so:</p> <pre><code>$ ls ./bin\ncete\n</code></pre>"},{"location":"#testing-cete","title":"Testing Cete","text":"<p>If you want to test your changes, run command like following:</p> <pre><code>$ make test\n</code></pre>"},{"location":"#packaging-cete","title":"Packaging Cete","text":""},{"location":"#linux","title":"Linux","text":"<pre><code>$ make GOOS=linux dist\n</code></pre>"},{"location":"#macos","title":"macOS","text":"<pre><code>$ make GOOS=darwin dist\n</code></pre>"},{"location":"#configure-cete","title":"Configure Cete","text":"CLI Flag Environment variable Configuration File Description --config-file - - config file. if omitted, cete.yaml in /etc and home directory will be searched --id CETE_ID id node ID --raft-address CETE_RAFT_ADDRESS raft_address Raft server listen address --grpc-address CETE_GRPC_ADDRESS grpc_address gRPC server listen address --http-address CETE_HTTP_ADDRESS http_address HTTP server listen address --data-directory CETE_DATA_DIRECTORY data_directory data directory which store the key-value store data and Raft logs --peer-grpc-address CETE_PEER_GRPC_ADDRESS peer_grpc_address listen address of the existing gRPC server in the joining cluster --certificate-file CETE_CERTIFICATE_FILE certificate_file path to the client server TLS certificate file --key-file CETE_KEY_FILE key_file path to the client server TLS key file --common-name CETE_COMMON_NAME common_name certificate common name --log-level CETE_LOG_LEVEL log_level log level --log-file CETE_LOG_FILE log_file log file --log-max-size CETE_LOG_MAX_SIZE log_max_size max size of a log file in megabytes --log-max-backups CETE_LOG_MAX_BACKUPS log_max_backups max backup count of log files --log-max-age CETE_LOG_MAX_AGE log_max_age max age of a log file in days --log-compress CETE_LOG_COMPRESS log_compress compress a log file"},{"location":"#starting-cete-node","title":"Starting Cete node","text":"<p>Starting cete is easy as follows:</p> <pre><code>$ ./bin/cete start --id=node1 --raft-address=:7000 --grpc-address=:9000 --http-address=:8000 --data-directory=/tmp/cete/node1\n</code></pre> <p>You can get the node information with the following command:</p> <pre><code>$ ./bin/cete node | jq .\n</code></pre> <p>or the following URL:</p> <pre><code>$ curl -X GET http://localhost:8000/v1/node | jq .\n</code></pre> <p>The result of the above command is:</p> <pre><code>{\n  \"node\": {\n    \"raft_address\": \":7000\",\n    \"metadata\": {\n      \"grpc_address\": \":9000\",\n      \"http_address\": \":8000\"\n    },\n    \"state\": \"Leader\"\n  }\n}\n</code></pre>"},{"location":"#health-check","title":"Health check","text":"<p>You can check the health status of the node.</p> <pre><code>$ ./bin/cete healthcheck | jq .\n</code></pre> <p>Also provides the following REST APIs</p>"},{"location":"#liveness-prove","title":"Liveness prove","text":"<p>This endpoint always returns 200 and should be used to check Cete health.</p> <pre><code>$ curl -X GET http://localhost:8000/v1/liveness_check | jq .\n</code></pre>"},{"location":"#readiness-probe","title":"Readiness probe","text":"<p>This endpoint returns 200 when Cete is ready to serve traffic (i.e. respond to queries).</p> <pre><code>$ curl -X GET http://localhost:8000/v1/readiness_check | jq .\n</code></pre>"},{"location":"#putting-a-key-value","title":"Putting a key-value","text":"<p>To put a key-value, execute the following command:</p> <pre><code>$ ./bin/cete set 1 value1\n</code></pre> <p>or, you can use the RESTful API as follows:</p> <pre><code>$ curl -X PUT 'http://127.0.0.1:8000/v1/data/1' --data-binary value1\n$ curl -X PUT 'http://127.0.0.1:8000/v1/data/2' -H \"Content-Type: image/jpeg\" --data-binary @/path/to/photo.jpg\n</code></pre>"},{"location":"#getting-a-key-value","title":"Getting a key-value","text":"<p>To get a key-value, execute the following command:</p> <pre><code>$ ./bin/cete get 1\n</code></pre> <p>or, you can use the RESTful API as follows:</p> <pre><code>$ curl -X GET 'http://127.0.0.1:8000/v1/data/1'\n</code></pre> <p>You can see the result. The result of the above command is:</p> <pre><code>value1\n</code></pre>"},{"location":"#deleting-a-key-value","title":"Deleting a key-value","text":"<p>Deleting a value by key, execute the following command:</p> <pre><code>$ ./bin/cete delete 1\n</code></pre> <p>or, you can use the RESTful API as follows:</p> <pre><code>$ curl -X DELETE 'http://127.0.0.1:8000/v1/data/1'\n</code></pre>"},{"location":"#bringing-up-a-cluster","title":"Bringing up a cluster","text":"<p>Cete is easy to bring up the cluster. Cete node is already running, but that is not fault tolerant. If you need to increase the fault tolerance, bring up 2 more data nodes like so:</p> <pre><code>$ ./bin/cete start --id=node2 --raft-address=:7001 --grpc-address=:9001 --http-address=:8001 --data-directory=/tmp/cete/node2 --peer-grpc-address=:9000\n$ ./bin/cete start --id=node3 --raft-address=:7002 --grpc-address=:9002 --http-address=:8002 --data-directory=/tmp/cete/node3 --peer-grpc-address=:9000\n</code></pre> <p>Above example shows each Cete node running on the same host, so each node must listen on different ports. This would not be necessary if each node ran on a different host.</p> <p>This instructs each new node to join an existing node, each node recognizes the joining clusters when started. So you have a 3-node cluster. That way you can tolerate the failure of 1 node. You can check the cluster with the following command:</p> <pre><code>$ ./bin/cete cluster | jq .\n</code></pre> <p>or, you can use the RESTful API as follows:</p> <pre><code>$ curl -X GET 'http://127.0.0.1:8000/v1/cluster' | jq .\n</code></pre> <p>You can see the result in JSON format. The result of the above command is:</p> <pre><code>{\n  \"cluster\": {\n    \"nodes\": {\n      \"node1\": {\n        \"raft_address\": \":7000\",\n        \"metadata\": {\n          \"grpc_address\": \":9000\",\n          \"http_address\": \":8000\"\n        },\n        \"state\": \"Leader\"\n      },\n      \"node2\": {\n        \"raft_address\": \":7001\",\n        \"metadata\": {\n          \"grpc_address\": \":9001\",\n          \"http_address\": \":8001\"\n        },\n        \"state\": \"Follower\"\n      },\n      \"node3\": {\n        \"raft_address\": \":7002\",\n        \"metadata\": {\n          \"grpc_address\": \":9002\",\n          \"http_address\": \":8002\"\n        },\n        \"state\": \"Follower\"\n      }\n    },\n    \"leader\": \"node1\"\n  }\n}\n</code></pre> <p>Recommend 3 or more odd number of nodes in the cluster. In failure scenarios, data loss is inevitable, so avoid deploying single nodes.</p> <p>The above example, the node joins to the cluster at startup, but you can also join the node that already started on standalone mode to the cluster later, as follows:</p> <pre><code>$ ./bin/cete join --grpc-addr=:9000 node2 127.0.0.1:9001\n</code></pre> <p>or, you can use the RESTful API as follows:</p> <pre><code>$ curl -X PUT 'http://127.0.0.1:8000/v1/cluster/node2' --data-binary '\n{\n  \"raft_address\": \":7001\",\n  \"metadata\": {\n    \"grpc_address\": \":9001\",\n    \"http_address\": \":8001\"\n  }\n}\n'\n</code></pre> <p>To remove a node from the cluster, execute the following command:</p> <pre><code>$ ./bin/cete leave --grpc-addr=:9000 node2\n</code></pre> <p>or, you can use the RESTful API as follows:</p> <pre><code>$ curl -X DELETE 'http://127.0.0.1:8000/v1/cluster/node2'\n</code></pre> <p>The following command indexes documents to any node in the cluster:</p> <pre><code>$ ./bin/cete set 1 value1 --grpc-address=:9000 \n</code></pre> <p>So, you can get the document from the node specified by the above command as follows:</p> <pre><code>$ ./bin/cete get 1 --grpc-address=:9000\n</code></pre> <p>You can see the result. The result of the above command is:</p> <pre><code>value1\n</code></pre> <p>You can also get the same document from other nodes in the cluster as follows:</p> <pre><code>$ ./bin/cete get 1 --grpc-address=:9001\n$ ./bin/cete get 1 --grpc-address=:9002\n</code></pre> <p>You can see the result. The result of the above command is:</p> <pre><code>value1\n</code></pre>"},{"location":"#cete-on-docker","title":"Cete on Docker","text":""},{"location":"#building-cete-docker-container-image-on-localhost","title":"Building Cete Docker container image on localhost","text":"<p>You can build the Docker container image like so:</p> <pre><code>$ make docker-build\n</code></pre>"},{"location":"#pulling-cete-docker-container-image-from-dockerio","title":"Pulling Cete Docker container image from docker.io","text":"<p>You can also use the Docker container image already registered in docker.io like so:</p> <pre><code>$ docker pull mosuka/cete:latest\n</code></pre> <p>See https://hub.docker.com/r/mosuka/cete/tags/</p>"},{"location":"#pulling-cete-docker-container-image-from-dockerio_1","title":"Pulling Cete Docker container image from docker.io","text":"<p>You can also use the Docker container image already registered in docker.io like so:</p> <pre><code>$ docker pull mosuka/cete:latest\n</code></pre>"},{"location":"#running-cete-node-on-docker","title":"Running Cete node on Docker","text":"<p>Running a Cete data node on Docker. Start Cete node like so:</p> <pre><code>$ docker run --rm --name cete-node1 \\\n    -p 7000:7000 \\\n    -p 8000:8000 \\\n    -p 9000:9000 \\\n    mosuka/cete:latest cete start \\\n      --id=node1 \\\n      --raft-address=:7000 \\\n      --grpc-address=:9000 \\\n      --http-address=:8000 \\\n      --data-directory=/tmp/cete/node1\n</code></pre> <p>You can execute the command in docker container as follows:</p> <pre><code>$ docker exec -it cete-node1 cete node --grpc-address=:9000\n</code></pre>"},{"location":"#securing-cete","title":"Securing Cete","text":"<p>Cete supports HTTPS access, ensuring that all communication between clients and a cluster is encrypted.</p>"},{"location":"#generating-a-certificate-and-private-key","title":"Generating a certificate and private key","text":"<p>One way to generate the necessary resources is via openssl. For example:</p> <pre><code>$ openssl req -x509 -nodes -newkey rsa:4096 -keyout ./etc/cete-key.pem -out ./etc/cete-cert.pem -days 365 -subj '/CN=localhost'\nGenerating a 4096 bit RSA private key\n............................++\n........++\nwriting new private key to 'key.pem'\n</code></pre>"},{"location":"#secure-cluster-example","title":"Secure cluster example","text":"<p>Starting a node with HTTPS enabled, node-to-node encryption, and with the above configuration file. It is assumed the HTTPS X.509 certificate and key are at the paths server.crt and key.pem respectively.</p> <pre><code>$ ./bin/cete start --id=node1 --raft-address=:7000 --grpc-address=:9000 --http-address=:8000 --data-directory=/tmp/cete/node1 --peer-grpc-address=:9000 --certificate-file=./etc/cert.pem --key-file=./etc/key.pem --common-name=localhost\n$ ./bin/cete start --id=node2 --raft-address=:7001 --grpc-address=:9001 --http-address=:8001 --data-directory=/tmp/cete/node2 --peer-grpc-address=:9000 --certificate-file=./etc/cert.pem --key-file=./etc/key.pem --common-name=localhost\n$ ./bin/cete start --id=node3 --raft-address=:7002 --grpc-address=:9002 --http-address=:8002 --data-directory=/tmp/cete/node3 --peer-grpc-address=:9000 --certificate-file=./etc/cert.pem --key-file=./etc/key.pem --common-name=localhost\n</code></pre> <p>You can access the cluster by adding a flag, such as the following command:</p> <pre><code>$ ./bin/cete cluster --grpc-address=:9000 --certificate-file=./cert.pem --common-name=localhost | jq .\n</code></pre> <p>or</p> <pre><code>$ curl -X GET https://localhost:8000/v1/cluster --cacert ./cert.pem | jq .\n</code></pre>"}]}